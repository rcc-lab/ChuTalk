## ChuTalk Server-Side Safety Features Implementation

This file contains all the server-side changes needed for App Store compliance (Guideline 1.2).

### 1. Database Tables

# Create reports table
docker exec -it chutalk_db psql -U postgres -d chutalk -c "
CREATE TABLE IF NOT EXISTS reports (
    id SERIAL PRIMARY KEY,
    reporter_id INTEGER NOT NULL REFERENCES users(id),
    reported_user_id INTEGER NOT NULL REFERENCES users(id),
    message_id INTEGER REFERENCES messages(id),
    reason TEXT NOT NULL,
    status VARCHAR(20) DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT NOW(),
    reviewed_at TIMESTAMP,
    reviewed_by INTEGER REFERENCES users(id),
    action_taken TEXT
);
CREATE INDEX idx_reports_status ON reports(status);
CREATE INDEX idx_reports_reported_user ON reports(reported_user_id);
"

# Create blocks table
docker exec -it chutalk_db psql -U postgres -d chutalk -c "
CREATE TABLE IF NOT EXISTS blocks (
    id SERIAL PRIMARY KEY,
    blocker_id INTEGER NOT NULL REFERENCES users(id),
    blocked_user_id INTEGER NOT NULL REFERENCES users(id),
    created_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(blocker_id, blocked_user_id)
);
CREATE INDEX idx_blocks_blocker ON blocks(blocker_id);
CREATE INDEX idx_blocks_blocked ON blocks(blocked_user_id);
"

# Add is_admin column to users table (for admin dashboard)
docker exec -it chutalk_db psql -U postgres -d chutalk -c "
ALTER TABLE users ADD COLUMN IF NOT EXISTS is_admin BOOLEAN DEFAULT FALSE;
"

### 2. Server.js API Endpoints

# Backup server.js
cd /srv/chutalk
cp server.js server.js.backup_$(date +%Y%m%d_%H%M%S)

# Add the following code to server.js after the existing endpoints

# --- REPORT ENDPOINTS ---

# POST /api/reports - Submit a report
app.post("/api/reports", auth, async (req, res) => {
  const { reported_user_id, message_id, reason } = req.body;
  const reporterId = req.user.uid;

  if (!reported_user_id || !reason) {
    return res.status(400).json({ ok: false, message: "Missing required fields" });
  }

  try {
    await pool.query(
      `INSERT INTO reports (reporter_id, reported_user_id, message_id, reason, status)
       VALUES ($1, $2, $3, $4, 'pending')`,
      [reporterId, reported_user_id, message_id, reason]
    );

    res.json({ ok: true, message: "通報を受け付けました" });
  } catch (err) {
    console.error("Error submitting report:", err);
    res.status(500).json({ ok: false, message: "Failed to submit report" });
  }
});

# GET /api/reports - Get all reports (admin only)
app.get("/api/reports", auth, async (req, res) => {
  try {
    // Check if user is admin
    const adminCheck = await pool.query(
      'SELECT is_admin FROM users WHERE id = $1',
      [req.user.uid]
    );

    if (!adminCheck.rows[0]?.is_admin) {
      return res.status(403).json({ error: "Admin access required" });
    }

    const result = await pool.query(`
      SELECT
        r.id,
        r.reporter_id,
        reporter.username as reporter_username,
        r.reported_user_id,
        reported.username as reported_username,
        r.message_id,
        r.reason,
        r.status,
        r.created_at,
        r.reviewed_at,
        r.reviewed_by,
        r.action_taken
      FROM reports r
      JOIN users reporter ON r.reporter_id = reporter.id
      JOIN users reported ON r.reported_user_id = reported.id
      ORDER BY r.created_at DESC
    `);

    res.json(result.rows);
  } catch (err) {
    console.error("Error fetching reports:", err);
    res.status(500).json({ error: err.message });
  }
});

# PUT /api/reports/:id - Update report status (admin only)
app.put("/api/reports/:id", auth, async (req, res) => {
  const reportId = req.params.id;
  const { status, action_taken } = req.body;

  try {
    // Check if user is admin
    const adminCheck = await pool.query(
      'SELECT is_admin FROM users WHERE id = $1',
      [req.user.uid]
    );

    if (!adminCheck.rows[0]?.is_admin) {
      return res.status(403).json({ ok: false, message: "Admin access required" });
    }

    await pool.query(
      `UPDATE reports
       SET status = $1, action_taken = $2, reviewed_at = NOW(), reviewed_by = $3
       WHERE id = $4`,
      [status, action_taken, req.user.uid, reportId]
    );

    res.json({ ok: true, message: "Report updated" });
  } catch (err) {
    console.error("Error updating report:", err);
    res.status(500).json({ ok: false, message: "Failed to update report" });
  }
});

# --- BLOCK ENDPOINTS ---

# POST /api/blocks - Block a user
app.post("/api/blocks", auth, async (req, res) => {
  const { blocked_user_id } = req.body;
  const blockerId = req.user.uid;

  if (!blocked_user_id) {
    return res.status(400).json({ ok: false, message: "Missing blocked_user_id" });
  }

  if (blockerId === blocked_user_id) {
    return res.status(400).json({ ok: false, message: "Cannot block yourself" });
  }

  try {
    await pool.query(
      `INSERT INTO blocks (blocker_id, blocked_user_id)
       VALUES ($1, $2)
       ON CONFLICT (blocker_id, blocked_user_id) DO NOTHING`,
      [blockerId, blocked_user_id]
    );

    res.json({ ok: true, message: "ユーザーをブロックしました" });
  } catch (err) {
    console.error("Error blocking user:", err);
    res.status(500).json({ ok: false, message: "Failed to block user" });
  }
});

# GET /api/blocks - Get blocked users
app.get("/api/blocks", auth, async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT u.id, u.username, u.display_name, u.profile_image_url, false as is_online, false as is_favorite
      FROM blocks b
      JOIN users u ON b.blocked_user_id = u.id
      WHERE b.blocker_id = $1
      ORDER BY u.display_name, u.username
    `, [req.user.uid]);

    res.json(result.rows);
  } catch (err) {
    console.error("Error fetching blocked users:", err);
    res.status(500).json({ error: err.message });
  }
});

# DELETE /api/blocks/:userId - Unblock a user
app.delete("/api/blocks/:userId", auth, async (req, res) => {
  const blockedUserId = parseInt(req.params.userId);
  const blockerId = req.user.uid;

  try {
    await pool.query(
      'DELETE FROM blocks WHERE blocker_id = $1 AND blocked_user_id = $2',
      [blockerId, blockedUserId]
    );

    res.json({ ok: true, message: "ユーザーのブロックを解除しました" });
  } catch (err) {
    console.error("Error unblocking user:", err);
    res.status(500).json({ ok: false, message: "Failed to unblock user" });
  }
});

# --- FILTER MESSAGES BY BLOCKS ---

# Modify GET /api/messages/:userId to exclude blocked users
# Replace the existing /api/messages/:userId endpoint with this:

app.get("/api/messages/:userId", auth, async (req, res) => {
  const userId = parseInt(req.params.userId);
  const currentUserId = req.user.uid;

  try {
    // Check if either user has blocked the other
    const blockCheck = await pool.query(
      `SELECT 1 FROM blocks
       WHERE (blocker_id = $1 AND blocked_user_id = $2)
          OR (blocker_id = $2 AND blocked_user_id = $1)`,
      [currentUserId, userId]
    );

    if (blockCheck.rows.length > 0) {
      // Users have blocked each other, return empty messages
      return res.json([]);
    }

    const result = await pool.query(`
      SELECT m.id, m.sender_id, m.receiver_id, m.body, m.message_type,
             m.image_url, m.video_url, m.is_read, m.created_at
      FROM messages m
      WHERE (m.sender_id = $1 AND m.receiver_id = $2)
         OR (m.sender_id = $2 AND m.receiver_id = $1)
      ORDER BY m.created_at ASC
    `, [currentUserId, userId]);

    res.json(result.rows);
  } catch (err) {
    console.error("Error fetching messages:", err);
    res.status(500).json({ error: err.message });
  }
});

# --- FILTER CONTACTS BY BLOCKS ---

# Modify GET /api/contacts to exclude blocked users
# Replace the existing /api/contacts endpoint with this:

app.get("/api/contacts", auth, async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT u.id, u.username, u.display_name, u.is_online, u.profile_image_url, c.is_favorite
      FROM contacts c
      JOIN users u ON c.contact_id = u.id
      LEFT JOIN blocks b1 ON (b1.blocker_id = $1 AND b1.blocked_user_id = u.id)
      LEFT JOIN blocks b2 ON (b2.blocker_id = u.id AND b2.blocked_user_id = $1)
      WHERE c.user_id = $1
        AND b1.id IS NULL  -- Not blocked by current user
        AND b2.id IS NULL  -- Not blocking current user
      ORDER BY c.is_favorite DESC, u.display_name, u.username
    `, [req.user.uid]);
    res.json(result.rows);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

### 3. Restart API Server

docker restart chutalk_api

### 4. Create Admin User

# Set first user as admin (change ID as needed)
docker exec -it chutalk_db psql -U postgres -d chutalk -c "
UPDATE users SET is_admin = TRUE WHERE id = 1;
"

### 5. Test the endpoints

# Test report submission
curl -X POST https://chutalk.ksc-sys.com/api/reports \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"reported_user_id": 2, "reason": "テスト通報"}'

# Test blocking
curl -X POST https://chutalk.ksc-sys.com/api/blocks \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"blocked_user_id": 2}'

# Test get blocked users
curl -X GET https://chutalk.ksc-sys.com/api/blocks \
  -H "Authorization: Bearer YOUR_TOKEN"
