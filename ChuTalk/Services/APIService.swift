//
//  APIService.swift
//  ChuTalk
//
//  Created by Claude Code
//

import Foundation
import UIKit
import AVFoundation

enum APIError: Error, LocalizedError {
    case invalidURL
    case invalidResponse
    case unauthorized
    case serverError(String)
    case networkError(Error)
    case decodingError(Error)

    var errorDescription: String? {
        switch self {
        case .invalidURL:
            return "Invalid URL"
        case .invalidResponse:
            return "Invalid response from server"
        case .unauthorized:
            return "Unauthorized access"
        case .serverError(let message):
            return message
        case .networkError(let error):
            return "Network error: \(error.localizedDescription)"
        case .decodingError(let error):
            return "Failed to decode response: \(error.localizedDescription)"
        }
    }
}

class APIService {
    static let shared = APIService()
    private var isAutoReloginInProgress = false  // ÂêåÊôÇÂÆüË°åÈò≤Ê≠¢

    private init() {}

    private func request<T: Decodable>(
        url: String,
        method: String = "GET",
        body: [String: Any]? = nil,
        requiresAuth: Bool = false,
        isRetry: Bool = false  // ÂÜçË©¶Ë°å„Éï„É©„Ç∞
    ) async throws -> T {
        let urlString = url  // ÂÖÉ„ÅÆURLÊñáÂ≠óÂàó„Çí‰øùÂ≠òÔºàÂÜçË©¶Ë°åÁî®Ôºâ
        guard let urlObject = URL(string: url) else {
            throw APIError.invalidURL
        }

        var request = URLRequest(url: urlObject)
        request.httpMethod = method
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")

        if requiresAuth {
            guard let token = KeychainManager.shared.get(key: Constants.Keychain.authToken) else {
                throw APIError.unauthorized
            }
            request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        }

        if let body = body {
            request.httpBody = try? JSONSerialization.data(withJSONObject: body)
        }

        do {
            let (data, response) = try await URLSession.shared.data(for: request)

            guard let httpResponse = response as? HTTPURLResponse else {
                throw APIError.invalidResponse
            }

            print("üì° Response status: \(httpResponse.statusCode)")
            if let dataString = String(data: data, encoding: .utf8) {
                // Truncate very long responses
                let maxLength = 500
                if dataString.count > maxLength {
                    print("üì° Response data (truncated): \(dataString.prefix(maxLength))...")
                } else {
                    print("üì° Response data: \(dataString)")
                }
            }

            if httpResponse.statusCode == 401 {
                // 401„Ç®„É©„Éº: „Éà„Éº„ÇØ„É≥ÊúüÈôêÂàá„Çå
                if !isRetry && requiresAuth {
                    // ÂàùÂõû„ÅÆ401„Ç®„É©„Éº ‚Üí Ëá™ÂãïÂÜç„É≠„Ç∞„Ç§„É≥„ÇíË©¶Ë°å
                    print("‚ö†Ô∏è APIService: 401 Unauthorized - attempting auto re-login...")

                    if try await attemptAutoRelogin() {
                        // ÂÜç„É≠„Ç∞„Ç§„É≥ÊàêÂäü ‚Üí ÂÖÉ„ÅÆ„É™„ÇØ„Ç®„Çπ„Éà„ÇíÂÜçË©¶Ë°å
                        print("‚úÖ APIService: Auto re-login successful, retrying request...")
                        return try await self.request(
                            url: urlString,  // ÂÖÉ„ÅÆURLÊñáÂ≠óÂàó„Çí‰ΩøÁî®
                            method: method,
                            body: body,
                            requiresAuth: requiresAuth,
                            isRetry: true  // ÂÜçË©¶Ë°å„Éï„É©„Ç∞„ÇíON
                        )
                    }
                }
                // ÂÜç„É≠„Ç∞„Ç§„É≥Â§±Êïó or 2ÂõûÁõÆ„ÅÆ401„Ç®„É©„Éº
                print("‚ùå APIService: Unauthorized - auto re-login failed or not attempted")
                throw APIError.unauthorized
            }

            guard (200...299).contains(httpResponse.statusCode) else {
                if let errorDict = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                   let message = errorDict["message"] as? String {
                    throw APIError.serverError(message)
                }
                throw APIError.serverError("Server returned status code: \(httpResponse.statusCode)")
            }

            do {
                let decoder = JSONDecoder()
                decoder.dateDecodingStrategy = .iso8601
                let result = try decoder.decode(T.self, from: data)
                print("‚úÖ Successfully decoded response")
                return result
            } catch {
                print("‚ùå Decoding error: \(error)")
                throw APIError.decodingError(error)
            }
        } catch let error as APIError {
            throw error
        } catch {
            throw APIError.networkError(error)
        }
    }

    // MARK: - Authentication

    func register(username: String, password: String, displayName: String) async throws -> RegisterResponse {
        print("üîµ Registering user: \(username)")
        print("üîµ Display name: \(displayName)")
        print("üîµ Password length: \(password.count)")
        print("üîµ Password (DEBUG): \(password)")
        FileLogger.shared.log("Registration - username: \(username), displayName: \(displayName), password: \(password)", category: "APIService")

        do {
            let response: RegisterResponse = try await request(
                url: Constants.API.register,
                method: "POST",
                body: [
                    "username": username,
                    "password": password,
                    "display_name": displayName  // „Çµ„Éº„Éê„Éº„ÅØ„Çπ„Éç„Éº„ÇØ„Ç±„Éº„Çπ„ÇíÊúüÂæÖ
                ]
            )
            print("‚úÖ Registration response: ok=\(response.ok), message=\(response.message ?? "nil")")
            FileLogger.shared.log("‚úÖ Registration successful for user: \(username)", category: "APIService")
            return response
        } catch {
            print("‚ùå Registration error: \(error)")
            FileLogger.shared.log("‚ùå Registration failed for user: \(username) - Error: \(error)", category: "APIService")
            throw error
        }
    }

    func login(username: String, password: String) async throws -> AuthResponse {
        print("üîµ APIService: Logging in user: \(username)")
        print("üîµ APIService: Password length: \(password.count)")
        print("üîµ APIService: Password (DEBUG): \(password)")
        FileLogger.shared.log("Login attempt - username: \(username), password length: \(password.count), password: \(password)", category: "APIService")

        do {
            let response: AuthResponse = try await request(
                url: Constants.API.login,
                method: "POST",
                body: [
                    "username": username,
                    "password": password
                ]
            )
            print("‚úÖ APIService: Login successful, token received")
            FileLogger.shared.log("‚úÖ Login successful for user: \(username)", category: "APIService")
            return response
        } catch {
            print("‚ùå APIService: Login failed - \(error)")
            FileLogger.shared.log("‚ùå Login failed for user: \(username) - Error: \(error)", category: "APIService")
            throw error
        }
    }

    // MARK: - TURN Credentials

    func getTurnCredentials() async throws -> TurnCredentials {
        return try await request(
            url: Constants.API.turnCredentials,
            requiresAuth: true
        )
    }

    // MARK: - Contacts

    func getContacts() async throws -> [Contact] {
        return try await request(
            url: Constants.API.contacts,
            requiresAuth: true
        )
    }

    func addContact(targetUsername: String) async throws -> AddContactResponse {
        return try await request(
            url: Constants.API.contacts,
            method: "POST",
            body: ["username": targetUsername],
            requiresAuth: true
        )
    }

    func deleteContact(contactId: Int) async throws {
        struct EmptyResponse: Codable {}
        let _: EmptyResponse = try await request(
            url: "\(Constants.API.contacts)/\(contactId)",
            method: "DELETE",
            requiresAuth: true
        )
    }

    // MARK: - Profile

    func updateProfileImage(_ imageUrl: String) async throws -> User {
        return try await request(
            url: "\(Constants.Server.baseURL)/api/users/profile",
            method: "PUT",
            body: ["profile_image_url": imageUrl],
            requiresAuth: true
        )
    }

    // MARK: - Reports

    func reportUser(reportedUserId: Int, messageId: Int?, reason: String) async throws -> ReportResponse {
        var body: [String: Any] = [
            "reported_user_id": reportedUserId,
            "reason": reason
        ]

        if let messageId = messageId {
            body["message_id"] = messageId
        }

        return try await request(
            url: "\(Constants.Server.baseURL)/api/reports",
            method: "POST",
            body: body,
            requiresAuth: true
        )
    }

    // MARK: - Blocking

    func blockUser(userId: Int) async throws -> ReportResponse {
        return try await request(
            url: "\(Constants.Server.baseURL)/api/blocks",
            method: "POST",
            body: ["blocked_user_id": userId],
            requiresAuth: true
        )
    }

    func unblockUser(userId: Int) async throws -> ReportResponse {
        return try await request(
            url: "\(Constants.Server.baseURL)/api/blocks/\(userId)",
            method: "DELETE",
            requiresAuth: true
        )
    }

    func getBlockedUsers() async throws -> [Contact] {
        return try await request(
            url: "\(Constants.Server.baseURL)/api/blocks",
            requiresAuth: true
        )
    }

    // MARK: - Messages

    func getMessages(userId: Int) async throws -> [Message] {
        return try await request(
            url: "\(Constants.API.messages)/\(userId)",
            requiresAuth: true
        )
    }

    func sendMessage(receiverId: Int, body: String, messageType: String = "text", imageUrl: String? = nil, videoUrl: String? = nil) async throws -> Message {
        var requestBody: [String: Any] = [
            "receiver_id": receiverId,
            "body": body,
            "message_type": messageType
        ]

        if let imageUrl = imageUrl {
            requestBody["image_url"] = imageUrl
        }

        if let videoUrl = videoUrl {
            requestBody["video_url"] = videoUrl
        }

        return try await request(
            url: Constants.API.messages,
            method: "POST",
            body: requestBody,
            requiresAuth: true
        )
    }

    func deleteMessages(userId: Int) async throws {
        struct DeleteResponse: Codable {
            let ok: Bool
        }
        print("üóëÔ∏è APIService: Deleting messages for userId: \(userId)")
        let response: DeleteResponse = try await request(
            url: "\(Constants.API.messages)/\(userId)",
            method: "DELETE",
            requiresAuth: true
        )
        print("üóëÔ∏è APIService: Delete response: ok=\(response.ok)")
    }

    func markMessagesAsRead(userId: Int) async throws {
        struct ReadResponse: Codable {
            let ok: Bool
            let count: Int?
        }
        print("üëÅÔ∏è APIService: Marking messages as read for userId: \(userId)")
        let response: ReadResponse = try await request(
            url: "\(Constants.API.messages)/\(userId)/read",
            method: "PUT",
            requiresAuth: true
        )
        print("üëÅÔ∏è APIService: Server marked \(response.count ?? 0) messages as read for user \(userId)")
    }

    // MARK: - Image Upload

    func uploadImage(_ image: UIImage) async throws -> String {
        print("üì§ APIService: Starting image upload")
        FileLogger.shared.log("üì§ Starting image upload", category: "APIService")

        // Resize image if too large (max 2000px on longest side)
        let maxDimension: CGFloat = 2000
        let resizedImage: UIImage

        if image.size.width > maxDimension || image.size.height > maxDimension {
            let scale = min(maxDimension / image.size.width, maxDimension / image.size.height)
            let newSize = CGSize(width: image.size.width * scale, height: image.size.height * scale)

            UIGraphicsBeginImageContextWithOptions(newSize, false, 1.0)
            image.draw(in: CGRect(origin: .zero, size: newSize))
            resizedImage = UIGraphicsGetImageFromCurrentImageContext() ?? image
            UIGraphicsEndImageContext()

            print("üìê APIService: Resized image from \(image.size) to \(newSize)")
            FileLogger.shared.log("üìê Resized image from \(image.size) to \(newSize)", category: "APIService")
        } else {
            resizedImage = image
        }

        // Try different compression qualities until size is acceptable (max 5MB)
        let maxSize = 5 * 1024 * 1024 // 5MB
        var compressionQuality: CGFloat = 0.8
        var imageData = resizedImage.jpegData(compressionQuality: compressionQuality)

        while let data = imageData, data.count > maxSize && compressionQuality > 0.1 {
            compressionQuality -= 0.1
            imageData = resizedImage.jpegData(compressionQuality: compressionQuality)
            print("üóúÔ∏è APIService: Trying compression quality \(compressionQuality), size: \(data.count) bytes")
        }

        guard let finalImageData = imageData else {
            print("‚ùå APIService: Failed to convert image to JPEG data")
            FileLogger.shared.log("‚ùå Failed to convert image to JPEG data", category: "APIService")
            throw APIError.invalidURL
        }

        print("‚úÖ APIService: Image converted to JPEG (\(finalImageData.count) bytes, quality: \(compressionQuality))")
        FileLogger.shared.log("‚úÖ Image converted to JPEG (\(finalImageData.count) bytes, quality: \(compressionQuality))", category: "APIService")

        let boundary = UUID().uuidString
        let uploadURL = "\(Constants.Server.baseURL)/api/upload"
        print("üì§ APIService: Upload URL: \(uploadURL)")

        var request = URLRequest(url: URL(string: uploadURL)!)
        request.httpMethod = "POST"
        request.setValue("multipart/form-data; boundary=\(boundary)", forHTTPHeaderField: "Content-Type")
        request.timeoutInterval = 60.0 // 60 seconds timeout for large uploads

        guard let token = KeychainManager.shared.get(key: Constants.Keychain.authToken) else {
            print("‚ùå APIService: No auth token found")
            FileLogger.shared.log("‚ùå No auth token found", category: "APIService")
            throw APIError.unauthorized
        }
        request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        print("‚úÖ APIService: Auth token added")

        var body = Data()

        // Add image data
        body.append("--\(boundary)\r\n".data(using: .utf8)!)
        body.append("Content-Disposition: form-data; name=\"image\"; filename=\"image.jpg\"\r\n".data(using: .utf8)!)
        body.append("Content-Type: image/jpeg\r\n\r\n".data(using: .utf8)!)
        body.append(finalImageData)
        body.append("\r\n".data(using: .utf8)!)
        body.append("--\(boundary)--\r\n".data(using: .utf8)!)

        request.httpBody = body
        print("‚úÖ APIService: Request body prepared (\(body.count) bytes)")
        FileLogger.shared.log("‚úÖ Request body prepared (\(body.count) bytes)", category: "APIService")

        print("üì§ APIService: Sending upload request...")
        FileLogger.shared.log("üì§ Sending upload request to \(uploadURL)", category: "APIService")

        let (data, response) = try await URLSession.shared.data(for: request)
        print("‚úÖ APIService: Received response")

        guard let httpResponse = response as? HTTPURLResponse else {
            print("‚ùå APIService: Invalid HTTP response")
            throw APIError.invalidResponse
        }

        print("üìä APIService: HTTP Status Code: \(httpResponse.statusCode)")
        FileLogger.shared.log("üìä HTTP Status Code: \(httpResponse.statusCode)", category: "APIService")

        guard (200...299).contains(httpResponse.statusCode) else {
            let responseString = String(data: data, encoding: .utf8) ?? "Unable to decode response"
            print("‚ùå APIService: Server error - Status: \(httpResponse.statusCode)")
            print("‚ùå APIService: Response body: \(responseString)")
            FileLogger.shared.log("‚ùå Server error - Status: \(httpResponse.statusCode), Body: \(responseString)", category: "APIService")

            if let errorDict = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
               let message = errorDict["message"] as? String {
                throw APIError.serverError(message)
            }
            throw APIError.serverError("Server returned status code: \(httpResponse.statusCode)")
        }

        let responseString = String(data: data, encoding: .utf8) ?? "Unable to decode response"
        print("üìä APIService: Response body: \(responseString)")
        FileLogger.shared.log("üìä Response body: \(responseString)", category: "APIService")

        struct UploadResponse: Codable {
            let imageUrl: String

            enum CodingKeys: String, CodingKey {
                case imageUrl = "image_url"
            }
        }

        let decoder = JSONDecoder()
        do {
            let uploadResponse = try decoder.decode(UploadResponse.self, from: data)
            print("‚úÖ APIService: Image uploaded successfully: \(uploadResponse.imageUrl)")
            FileLogger.shared.log("‚úÖ Image uploaded successfully: \(uploadResponse.imageUrl)", category: "APIService")
            return uploadResponse.imageUrl
        } catch {
            print("‚ùå APIService: Failed to decode response: \(error)")
            print("‚ùå APIService: Response data: \(responseString)")
            FileLogger.shared.log("‚ùå Failed to decode response: \(error), Data: \(responseString)", category: "APIService")
            throw APIError.decodingError(error)
        }
    }

    // MARK: - Video Upload

    private func compressVideo(url: URL) async throws -> URL {
        print("üé¨ APIService: Starting video compression")
        FileLogger.shared.log("üé¨ Starting video compression", category: "APIService")

        let asset = AVURLAsset(url: url)

        // Check if video needs compression
        guard let videoTrack = try? await asset.loadTracks(withMediaType: .video).first else {
            print("‚ö†Ô∏è APIService: No video track found, using original")
            return url
        }

        // Get file size
        let fileSize = try? FileManager.default.attributesOfItem(atPath: url.path)[.size] as? Int64 ?? 0
        let fileSizeMB = Double(fileSize ?? 0) / (1024 * 1024)
        print("üìä APIService: Original video size: \(String(format: "%.2f", fileSizeMB)) MB")

        // If file is already small enough (< 50MB), don't compress
        if fileSizeMB < 50 {
            print("‚úÖ APIService: Video is small enough, skipping compression")
            return url
        }

        // Create export session
        guard let exportSession = AVAssetExportSession(asset: asset, presetName: AVAssetExportPresetMediumQuality) else {
            print("‚ö†Ô∏è APIService: Cannot create export session, using original")
            return url
        }

        // Create temporary output URL
        let outputURL = FileManager.default.temporaryDirectory
            .appendingPathComponent(UUID().uuidString)
            .appendingPathExtension("mp4")

        exportSession.outputURL = outputURL
        exportSession.outputFileType = .mp4
        exportSession.shouldOptimizeForNetworkUse = true

        // Export video
        await exportSession.export()

        if exportSession.status == .completed {
            let compressedSize = try? FileManager.default.attributesOfItem(atPath: outputURL.path)[.size] as? Int64 ?? 0
            let compressedSizeMB = Double(compressedSize ?? 0) / (1024 * 1024)
            print("‚úÖ APIService: Video compressed: \(String(format: "%.2f", fileSizeMB)) MB ‚Üí \(String(format: "%.2f", compressedSizeMB)) MB")
            FileLogger.shared.log("‚úÖ Video compressed: \(String(format: "%.2f", fileSizeMB)) MB ‚Üí \(String(format: "%.2f", compressedSizeMB)) MB", category: "APIService")
            return outputURL
        } else {
            print("‚ö†Ô∏è APIService: Compression failed (\(exportSession.status.rawValue)), using original")
            if let error = exportSession.error {
                print("‚ö†Ô∏è APIService: Compression error: \(error)")
            }
            return url
        }
    }

    func uploadVideo(url: URL) async throws -> String {
        print("üì§ APIService: Starting video upload")
        FileLogger.shared.log("üì§ Starting video upload", category: "APIService")

        // Compress video first
        let compressedURL = try await compressVideo(url: url)

        let videoData: Data
        do {
            videoData = try Data(contentsOf: compressedURL)
            print("‚úÖ APIService: Video data loaded (\(videoData.count) bytes)")
            FileLogger.shared.log("‚úÖ Video data loaded (\(videoData.count) bytes)", category: "APIService")

            // Clean up temporary compressed file if different from original
            if compressedURL != url {
                try? FileManager.default.removeItem(at: compressedURL)
            }
        } catch {
            print("‚ùå APIService: Failed to load video data: \(error)")
            FileLogger.shared.log("‚ùå Failed to load video data: \(error)", category: "APIService")
            throw error
        }

        let boundary = UUID().uuidString
        let uploadURL = "\(Constants.Server.baseURL)/api/upload"
        print("üì§ APIService: Upload URL: \(uploadURL)")

        var request = URLRequest(url: URL(string: uploadURL)!)
        request.httpMethod = "POST"
        request.setValue("multipart/form-data; boundary=\(boundary)", forHTTPHeaderField: "Content-Type")

        guard let token = KeychainManager.shared.get(key: Constants.Keychain.authToken) else {
            print("‚ùå APIService: No auth token found")
            throw APIError.unauthorized
        }
        request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        print("‚úÖ APIService: Auth token added")

        var body = Data()

        // Add video data
        let filename = url.lastPathComponent
        let mimeType = "video/mp4"

        body.append("--\(boundary)\r\n".data(using: .utf8)!)
        body.append("Content-Disposition: form-data; name=\"video\"; filename=\"\(filename)\"\r\n".data(using: .utf8)!)
        body.append("Content-Type: \(mimeType)\r\n\r\n".data(using: .utf8)!)
        body.append(videoData)
        body.append("\r\n".data(using: .utf8)!)
        body.append("--\(boundary)--\r\n".data(using: .utf8)!)

        request.httpBody = body
        print("‚úÖ APIService: Request body prepared (\(body.count) bytes)")

        print("üì§ APIService: Sending upload request...")

        let (data, response) = try await URLSession.shared.data(for: request)
        print("‚úÖ APIService: Received response")

        guard let httpResponse = response as? HTTPURLResponse else {
            print("‚ùå APIService: Invalid HTTP response")
            throw APIError.invalidResponse
        }

        print("üìä APIService: HTTP Status Code: \(httpResponse.statusCode)")
        FileLogger.shared.log("üìä HTTP Status Code: \(httpResponse.statusCode)", category: "APIService")

        guard (200...299).contains(httpResponse.statusCode) else {
            let responseString = String(data: data, encoding: .utf8) ?? "Unable to decode response"
            print("‚ùå APIService: Server error - Status: \(httpResponse.statusCode)")
            print("‚ùå APIService: Response body: \(responseString)")
            FileLogger.shared.log("‚ùå Server error - Status: \(httpResponse.statusCode), Body: \(responseString)", category: "APIService")

            if let errorDict = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
               let message = errorDict["message"] as? String {
                throw APIError.serverError(message)
            }
            throw APIError.serverError("Server returned status code: \(httpResponse.statusCode)")
        }

        let responseString = String(data: data, encoding: .utf8) ?? "Unable to decode response"
        print("üìä APIService: Response body: \(responseString)")
        FileLogger.shared.log("üìä Response body: \(responseString)", category: "APIService")

        struct UploadResponse: Codable {
            let videoUrl: String

            enum CodingKeys: String, CodingKey {
                case videoUrl = "video_url"
            }
        }

        let decoder = JSONDecoder()
        do {
            let uploadResponse = try decoder.decode(UploadResponse.self, from: data)
            print("‚úÖ APIService: Video uploaded successfully: \(uploadResponse.videoUrl)")
            FileLogger.shared.log("‚úÖ Video uploaded successfully: \(uploadResponse.videoUrl)", category: "APIService")
            return uploadResponse.videoUrl
        } catch {
            print("‚ùå APIService: Failed to decode response: \(error)")
            print("‚ùå APIService: Response data: \(responseString)")
            FileLogger.shared.log("‚ùå Failed to decode response: \(error), Data: \(responseString)", category: "APIService")
            throw APIError.decodingError(error)
        }
    }

    // MARK: - User Search

    func searchUsers(query: String) async throws -> [Contact] {
        guard let encodedQuery = query.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) else {
            throw APIError.invalidURL
        }
        return try await request(
            url: "\(Constants.API.userSearch)?q=\(encodedQuery)",
            requiresAuth: true
        )
    }

    // MARK: - Calls

    func recordCall(calleeId: Int, callType: String) async throws -> CallHistory {
        return try await request(
            url: Constants.API.calls,
            method: "POST",
            body: [
                "callee_id": calleeId,
                "call_type": callType
            ],
            requiresAuth: true
        )
    }

    func getCallHistory() async throws -> [CallHistory] {
        print("üìû APIService: Fetching call history from \(Constants.API.calls)")
        let history: [CallHistory] = try await request(
            url: Constants.API.calls,
            method: "GET",
            requiresAuth: true
        )
        print("üìû APIService: Successfully decoded \(history.count) call history items")
        return history
    }

    // MARK: - Device Token Registration

    func registerVoIPDeviceToken(voipDeviceToken: String, bundleId: String, platform: String) async throws {
        struct EmptyResponse: Codable {}
        let _: EmptyResponse = try await request(
            url: "\(Constants.Server.apiURL)/me/devices",
            method: "PUT",
            body: [
                "voipDeviceToken": voipDeviceToken,
                "bundleId": bundleId,
                "platform": platform
            ],
            requiresAuth: true
        )
        print("‚úÖ APIService: VoIP device token registered")
    }

    // MARK: - Call Signaling

    func sendSignal(callId: String, action: String, data: [String: Any]) async throws {
        struct EmptyResponse: Codable {}
        let _: EmptyResponse = try await request(
            url: Constants.API.callSignal,
            method: "POST",
            body: [
                "callId": callId,
                "action": action,
                "data": data
            ],
            requiresAuth: true
        )
    }

    func getSignals(callId: String) async throws -> [[String: Any]] {
        guard let url = URL(string: "\(Constants.API.callSignal)/\(callId)") else {
            throw APIError.invalidURL
        }

        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")

        if let token = KeychainManager.shared.get(key: Constants.Keychain.authToken) {
            request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        }

        let (data, response) = try await URLSession.shared.data(for: request)

        guard let httpResponse = response as? HTTPURLResponse else {
            throw APIError.invalidResponse
        }

        if httpResponse.statusCode == 401 {
            throw APIError.unauthorized
        }

        if httpResponse.statusCode != 200 {
            throw APIError.serverError("Server returned status code: \(httpResponse.statusCode)")
        }

        let json = try JSONSerialization.jsonObject(with: data) as? [[String: Any]] ?? []
        return json
    }

    // offer„Ç∑„Ç∞„Éä„É´„ÅÆSDP„ÇíÁõ¥Êé•ÂèñÂæóÔºà‰∏°Êñπ„ÅÆ„É¨„Çπ„Éù„É≥„ÇπÂΩ¢Âºè„Å´ÂØæÂøúÔºâ
    func getOfferSDP(callId: String) async throws -> String? {
        guard let url = URL(string: "\(Constants.API.callSignal)/\(callId)") else {
            throw APIError.invalidURL
        }

        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")

        if let token = KeychainManager.shared.get(key: Constants.Keychain.authToken) {
            request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        }

        let (data, response) = try await URLSession.shared.data(for: request)

        guard let httpResponse = response as? HTTPURLResponse else {
            throw APIError.invalidResponse
        }

        if httpResponse.statusCode == 401 {
            throw APIError.unauthorized
        }

        if httpResponse.statusCode != 200 {
            throw APIError.serverError("Server returned status code: \(httpResponse.statusCode)")
        }

        guard let jsonObject = try? JSONSerialization.jsonObject(with: data) else {
            return nil
        }

        // ÂΩ¢Âºè1: „Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÂΩ¢Âºè {"offer": {"sdp": "..."}, "candidates": [...]}
        if let jsonDict = jsonObject as? [String: Any],
           let offer = jsonDict["offer"] as? [String: Any],
           let sdp = offer["sdp"] as? String,
           !sdp.isEmpty {
            print("‚úÖ APIService: Found offer SDP (object format)")
            return sdp
        }

        // ÂΩ¢Âºè2: ÈÖçÂàóÂΩ¢Âºè [{"action": "offer", "data": {"sdp": "..."}}]
        if let jsonArray = jsonObject as? [[String: Any]] {
            for signal in jsonArray {
                if let action = signal["action"] as? String,
                   action == "offer",
                   let signalData = signal["data"] as? [String: Any],
                   let sdp = signalData["sdp"] as? String,
                   !sdp.isEmpty {
                    print("‚úÖ APIService: Found offer SDP (array format)")
                    return sdp
                }
            }
        }

        print("‚ö†Ô∏è APIService: No offer SDP found in response")
        return nil
    }

    // MARK: - Answer SDP

    func saveAnswer(callId: String, sdp: String, from: Int, to: Int) async throws {
        guard let url = URL(string: "\(Constants.API.callSignal)/\(callId)") else {
            throw APIError.invalidURL
        }

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")

        if let token = KeychainManager.shared.get(key: Constants.Keychain.authToken) {
            request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        }

        let body: [String: Any] = [
            "action": "answer",
            "data": [
                "sdp": sdp,
                "from": from,
                "to": to
            ]
        ]

        request.httpBody = try? JSONSerialization.data(withJSONObject: body)

        let (data, response) = try await URLSession.shared.data(for: request)

        guard let httpResponse = response as? HTTPURLResponse else {
            throw APIError.invalidResponse
        }

        if httpResponse.statusCode == 401 {
            throw APIError.unauthorized
        }

        if httpResponse.statusCode != 200 {
            throw APIError.serverError("Server returned status code: \(httpResponse.statusCode)")
        }

        print("‚úÖ APIService: Answer saved to API for callId: \(callId)")
    }

    func getAnswerSDP(callId: String) async throws -> String? {
        guard let url = URL(string: "\(Constants.API.callSignal)/\(callId)") else {
            throw APIError.invalidURL
        }

        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")

        if let token = KeychainManager.shared.get(key: Constants.Keychain.authToken) {
            request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        }

        let (data, response) = try await URLSession.shared.data(for: request)

        guard let httpResponse = response as? HTTPURLResponse else {
            throw APIError.invalidResponse
        }

        if httpResponse.statusCode == 401 {
            throw APIError.unauthorized
        }

        if httpResponse.statusCode != 200 {
            return nil
        }

        guard let jsonObject = try? JSONSerialization.jsonObject(with: data) else {
            return nil
        }

        // ÂΩ¢Âºè1: „Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÂΩ¢Âºè {"offer": {...}, "answer": {"sdp": "..."}, "candidates": [...]}
        if let jsonDict = jsonObject as? [String: Any],
           let answer = jsonDict["answer"] as? [String: Any],
           let sdp = answer["sdp"] as? String,
           !sdp.isEmpty {
            print("‚úÖ APIService: Found answer SDP (object format)")
            return sdp
        }

        // ÂΩ¢Âºè2: ÈÖçÂàóÂΩ¢Âºè [{"action": "answer", "data": {"sdp": "..."}}]
        if let jsonArray = jsonObject as? [[String: Any]] {
            for signal in jsonArray {
                if let action = signal["action"] as? String,
                   action == "answer",
                   let signalData = signal["data"] as? [String: Any],
                   let sdp = signalData["sdp"] as? String,
                   !sdp.isEmpty {
                    print("‚úÖ APIService: Found answer SDP (array format)")
                    return sdp
                }
            }
        }

        return nil
    }

    // MARK: - Auto Re-login

    /// Ëá™ÂãïÂÜç„É≠„Ç∞„Ç§„É≥Ê©üËÉΩÔºàLINE„ÅÆ„Çà„ÅÜ„Å´ÂÜç„É≠„Ç∞„Ç§„É≥‰∏çË¶Å„Å´„Åô„ÇãÔºâ
    private func attemptAutoRelogin() async throws -> Bool {
        // ÂêåÊôÇÂÆüË°åÈò≤Ê≠¢
        guard !isAutoReloginInProgress else {
            print("‚ö†Ô∏è APIService: Auto re-login already in progress, skipping...")
            return false
        }

        isAutoReloginInProgress = true
        defer { isAutoReloginInProgress = false }

        // Keychain„Åã„Çâ‰øùÂ≠ò„Åï„Çå„Åüusername/password„ÇíÂèñÂæó
        guard let username = KeychainManager.shared.get(key: Constants.Keychain.username),
              let password = KeychainManager.shared.get(key: Constants.Keychain.password) else {
            print("‚ùå APIService: No saved credentials for auto re-login")
            return false
        }

        print("üîÑ APIService: Attempting auto re-login for user: \(username)")

        do {
            // AuthService„ÅÆloginÈñ¢Êï∞„ÇíÂëº„Å≥Âá∫„Åó„Å¶ÂÜç„É≠„Ç∞„Ç§„É≥
            try await AuthService.shared.login(username: username, password: password)
            print("‚úÖ APIService: Auto re-login successful!")
            return true
        } catch {
            print("‚ùå APIService: Auto re-login failed: \(error.localizedDescription)")
            return false
        }
    }
}
