//
//  MessagingService.swift
//  ChuTalk
//
//  Created by Claude Code
//

import Foundation
import Combine
import UIKit

class MessagingService: ObservableObject {
    static let shared = MessagingService()

    @Published var conversations: [Int: [Message]] = [:]
    @Published var unreadCounts: [Int: Int] = [:]

    private var cancellables = Set<AnyCancellable>()
    private var messageTimer: Timer?
    private var activeConversationUserId: Int?

    private init() {
        setupMessageListener()
        loadLocalMessages()
    }

    deinit {
        stopPolling()
    }

    private func loadLocalMessages() {
        guard let currentUserId = AuthService.shared.currentUser?.id else { return }
        let allMessages = LocalStorageManager.shared.loadMessages()

        // Group messages by conversation
        for message in allMessages {
            let otherUserId = message.senderId == currentUserId ? message.receiverId : message.senderId
            if conversations[otherUserId] == nil {
                conversations[otherUserId] = []
            }
            conversations[otherUserId]?.append(message)
        }

        // Sort messages in each conversation
        for (userId, _) in conversations {
            conversations[userId]?.sort { $0.timestamp < $1.timestamp }
        }

        updateUnreadCounts()
        print("‚úÖ MessagingService: Loaded \(allMessages.count) messages from local storage")
    }

    private func setupMessageListener() {
        SocketService.shared.onMessageReceived = { [weak self] from, body, timestamp in
            self?.handleReceivedMessage(from: from, body: body, timestamp: timestamp)
        }
    }

    // Fetch message history from server
    func fetchMessages(for userId: Int) async {
        guard let currentUserId = AuthService.shared.currentUser?.id else { return }

        do {
            let messages = try await APIService.shared.getMessages(userId: userId)

            await MainActor.run {
                // „Çµ„Éº„Éê„Éº„Åã„ÇâÂèñÂæó„Åó„Åü„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆÊó¢Ë™≠Áä∂ÊÖã„ÇíÂèçÊò†
                // ÈÄÅ‰ø°„É°„ÉÉ„Çª„Éº„Ç∏ÔºàËá™ÂàÜ‚ÜíÁõ∏ÊâãÔºâ„ÅÆÂ†¥Âêà„ÄÅ„Çµ„Éº„Éê„Éº„ÅÆis_read„ÅåÁõ∏Êâã„ÅÆÊó¢Ë™≠Áä∂ÊÖã„ÇíË°®„Åô
                // Âèó‰ø°„É°„ÉÉ„Çª„Éº„Ç∏ÔºàÁõ∏Êâã‚ÜíËá™ÂàÜÔºâ„ÅÆÂ†¥Âêà„ÄÅ„É≠„Éº„Ç´„É´„ÅÆÊó¢Ë™≠Áä∂ÊÖã„Çí‰ΩøÁî®
                var updatedMessages = messages.sorted { $0.timestamp < $1.timestamp }

                FileLogger.shared.log("üìä Processing \(updatedMessages.count) messages for user \(userId), currentUserId=\(currentUserId)", category: "MessagingService")
                print("üìä MessagingService: Processing \(updatedMessages.count) messages for user \(userId), currentUserId=\(currentUserId)")

                // Êó¢Â≠ò„ÅÆ„É≠„Éº„Ç´„É´„É°„ÉÉ„Çª„Éº„Ç∏„Å®ÊØîËºÉ„Åó„Å¶„ÄÅÂèó‰ø°„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆÊó¢Ë™≠Áä∂ÊÖã„Çí‰øùÊåÅ
                for i in 0..<updatedMessages.count {
                    let msg = updatedMessages[i]
                    let logMsg = "üìä Message \(i): sender=\(msg.senderId), receiver=\(msg.receiverId), isRead=\(msg.isRead), isSentByMe=\(msg.isSentByCurrentUser)"
                    FileLogger.shared.log(logMsg, category: "MessagingService")
                    print(logMsg)

                    // Âèó‰ø°„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆÂ†¥Âêà„ÄÅ„É≠„Éº„Ç´„É´„ÅÆÊó¢Ë™≠Áä∂ÊÖã„ÇíÂÑ™ÂÖà
                    if msg.receiverId == currentUserId {
                        if let existingMessages = self.conversations[userId],
                           let existingMsg = existingMessages.first(where: { $0.serverId == msg.serverId }) {
                            updatedMessages[i].isRead = existingMsg.isRead
                            let log = "  ‚Üí Âèó‰ø°„É°„ÉÉ„Çª„Éº„Ç∏: „É≠„Éº„Ç´„É´„ÅÆÊó¢Ë™≠Áä∂ÊÖã„Çí‰ΩøÁî® isRead=\(existingMsg.isRead)"
                            FileLogger.shared.log(log, category: "MessagingService")
                            print(log)
                        } else {
                            let log = "  ‚Üí Âèó‰ø°„É°„ÉÉ„Çª„Éº„Ç∏: Êó¢Â≠ò„É°„ÉÉ„Çª„Éº„Ç∏„Å™„Åó„ÄÅ„Çµ„Éº„Éê„Éº„ÅÆÁä∂ÊÖã„Çí‰ΩøÁî® isRead=\(msg.isRead)"
                            FileLogger.shared.log(log, category: "MessagingService")
                            print(log)
                        }
                    } else {
                        // ÈÄÅ‰ø°„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆÂ†¥Âêà„ÄÅ„Çµ„Éº„Éê„Éº„ÅÆÊó¢Ë™≠Áä∂ÊÖã„Çí„Åù„ÅÆ„Åæ„Åæ‰ΩøÁî®ÔºàÁõ∏Êâã„ÅÆÊó¢Ë™≠Áä∂ÊÖãÔºâ
                        let log = "  ‚Üí ÈÄÅ‰ø°„É°„ÉÉ„Çª„Éº„Ç∏: „Çµ„Éº„Éê„Éº„ÅÆÊó¢Ë™≠Áä∂ÊÖã„Çí‰ΩøÁî® isRead=\(msg.isRead)"
                        FileLogger.shared.log(log, category: "MessagingService")
                        print(log)
                    }
                }

                self.conversations[userId] = updatedMessages
                self.updateUnreadCounts()

                // Update local storage for this specific user only
                // 1. Load all existing messages
                var allMessages = LocalStorageManager.shared.loadMessages()

                // 2. Remove old messages for this user
                allMessages.removeAll { message in
                    (message.senderId == userId && message.receiverId == currentUserId) ||
                    (message.senderId == currentUserId && message.receiverId == userId)
                }

                // 3. Add new messages from server
                allMessages.append(contentsOf: updatedMessages)

                // 4. Save updated messages
                LocalStorageManager.shared.saveMessages(allMessages)

                print("‚úÖ MessagingService: Fetched \(messages.count) messages from server for user \(userId)")
            }
        } catch {
            print("‚ùå MessagingService: Failed to fetch messages - \(error)")
            // Use local storage as fallback
            await MainActor.run {
                let localMessages = LocalStorageManager.shared.getMessages(for: userId, currentUserId: currentUserId)
                self.conversations[userId] = localMessages
                self.updateUnreadCounts()
            }
        }
    }

    func sendMessage(to userId: Int, content: String) async -> Bool {
        guard let currentUserId = AuthService.shared.currentUser?.id else {
            print("‚ùå MessagingService: No current user")
            return false
        }

        print("üì§ MessagingService: Attempting to send message to user \(userId)")
        print("üì§ MessagingService: Message content: \(content)")

        do {
            let message = try await APIService.shared.sendMessage(receiverId: userId, body: content)

            await MainActor.run {
                // Add to local conversations
                if self.conversations[userId] == nil {
                    self.conversations[userId] = []
                }
                self.conversations[userId]?.append(message)

                // Save to local storage
                LocalStorageManager.shared.addMessage(message)

                print("‚úÖ MessagingService: Sent message via API to \(userId)")

                // Also send via Socket.IO for real-time delivery and push notifications
                SocketService.shared.sendMessage(to: userId, body: content)
                print("‚úÖ MessagingService: Sent message via Socket.IO to \(userId)")
            }
            return true
        } catch {
            print("‚ùå MessagingService: Failed to send via API - \(error)")
            if let apiError = error as? APIError {
                print("‚ùå MessagingService: API Error details: \(apiError.localizedDescription)")
            }

            // Create local message even if API fails
            let localMessage = Message(
                senderId: currentUserId,
                receiverId: userId,
                content: content
            )

            await MainActor.run {
                if self.conversations[userId] == nil {
                    self.conversations[userId] = []
                }
                self.conversations[userId]?.append(localMessage)
                LocalStorageManager.shared.addMessage(localMessage)
                print("üíæ MessagingService: Saved message locally (API failed)")
            }
            return false
        }
    }

    func sendImageMessage(to userId: Int, image: UIImage) async -> Bool {
        guard let currentUserId = AuthService.shared.currentUser?.id else {
            print("‚ùå MessagingService: No current user")
            return false
        }

        print("üì§ MessagingService: Attempting to send image to user \(userId)")

        do {
            // First, upload the image
            let imageUrl = try await APIService.shared.uploadImage(image)
            print("‚úÖ MessagingService: Image uploaded to \(imageUrl)")

            // Then send the message with the image URL
            let message = try await APIService.shared.sendMessage(
                receiverId: userId,
                body: "[ÁîªÂÉè]",
                messageType: "image",
                imageUrl: imageUrl
            )

            await MainActor.run {
                // Add to local conversations
                if self.conversations[userId] == nil {
                    self.conversations[userId] = []
                }
                self.conversations[userId]?.append(message)

                // Save to local storage
                LocalStorageManager.shared.addMessage(message)

                print("‚úÖ MessagingService: Sent image message via API to \(userId)")

                // Also send via Socket.IO for real-time delivery
                SocketService.shared.sendMessage(to: userId, body: "[ÁîªÂÉè]")
                print("‚úÖ MessagingService: Sent image notification via Socket.IO to \(userId)")
            }
            return true
        } catch {
            print("‚ùå MessagingService: Failed to send image - \(error)")
            FileLogger.shared.log("‚ùå Failed to send image: \(error)", category: "MessagingService")
            if let apiError = error as? APIError {
                print("‚ùå MessagingService: API Error details: \(apiError.localizedDescription)")
                FileLogger.shared.log("‚ùå API Error: \(apiError.localizedDescription)", category: "MessagingService")
            }
            if let urlError = error as? URLError {
                print("‚ùå MessagingService: URL Error: \(urlError.localizedDescription) (Code: \(urlError.code.rawValue))")
                FileLogger.shared.log("‚ùå URL Error: \(urlError.localizedDescription) (Code: \(urlError.code.rawValue))", category: "MessagingService")
            }
            return false
        }
    }

    func sendVideoMessage(to userId: Int, videoUrl: URL) async -> Bool {
        guard let currentUserId = AuthService.shared.currentUser?.id else {
            print("‚ùå MessagingService: No current user")
            return false
        }

        print("üì§ MessagingService: Attempting to send video to user \(userId)")

        do {
            // First, upload the video
            let uploadedVideoUrl = try await APIService.shared.uploadVideo(url: videoUrl)
            print("‚úÖ MessagingService: Video uploaded to \(uploadedVideoUrl)")

            // Then send the message with the video URL
            let message = try await APIService.shared.sendMessage(
                receiverId: userId,
                body: "[ÂãïÁîª]",
                messageType: "video",
                videoUrl: uploadedVideoUrl
            )

            await MainActor.run {
                // Add to local conversations
                if self.conversations[userId] == nil {
                    self.conversations[userId] = []
                }
                self.conversations[userId]?.append(message)

                // Save to local storage
                LocalStorageManager.shared.addMessage(message)

                print("‚úÖ MessagingService: Sent video message via API to \(userId)")

                // Also send via Socket.IO for real-time delivery
                SocketService.shared.sendMessage(to: userId, body: "[ÂãïÁîª]")
                print("‚úÖ MessagingService: Sent video notification via Socket.IO to \(userId)")
            }
            return true
        } catch {
            print("‚ùå MessagingService: Failed to send video - \(error)")
            if let apiError = error as? APIError {
                print("‚ùå MessagingService: API Error details: \(apiError.localizedDescription)")
            }
            return false
        }
    }

    private func handleReceivedMessage(from: Int, body: String, timestamp: Date) {
        guard let currentUserId = AuthService.shared.currentUser?.id else { return }

        // Ignore messages from ourselves (echo from socket)
        if from == currentUserId {
            print("‚ö†Ô∏è MessagingService: Ignoring message from self (echo)")
            return
        }

        let message = Message(
            senderId: from,
            receiverId: currentUserId,
            content: body,
            timestamp: timestamp,
            isRead: false
        )

        // Check if message already exists
        if let existingMessages = conversations[from],
           existingMessages.contains(where: { $0.timestamp == message.timestamp && $0.content == message.content }) {
            print("‚ö†Ô∏è MessagingService: Message already exists, skipping")
            return
        }

        // Add to conversations
        if conversations[from] == nil {
            conversations[from] = []
        }
        conversations[from]?.append(message)
        conversations[from]?.sort { $0.timestamp < $1.timestamp }

        // Save to local storage
        LocalStorageManager.shared.addMessage(message)

        // Update unread count
        updateUnreadCounts()

        // Post notification for new message
        NotificationCenter.default.post(name: .newMessageReceived, object: nil, userInfo: ["userId": from])

        print("‚úÖ MessagingService: Received message from \(from)")
    }

    func markMessagesAsRead(for userId: Int) {
        guard var messages = conversations[userId] else { return }

        var hasChanges = false
        var hasUnreadFromOther = false

        for i in 0..<messages.count {
            if !messages[i].isSentByCurrentUser {
                // Track if there are any messages from the other user (read or unread)
                hasUnreadFromOther = true

                if !messages[i].isRead {
                    messages[i].isRead = true
                    hasChanges = true

                    // Update in local storage
                    LocalStorageManager.shared.updateMessage(messages[i])
                }
            }
        }

        if hasChanges {
            conversations[userId] = messages
            updateUnreadCounts()
            let log = "‚úÖ Marked messages as read for user \(userId)"
            FileLogger.shared.log(log, category: "MessagingService")
            print("‚úÖ MessagingService: \(log)")
        }

        // Always notify server if there are any messages from the other user
        // This ensures the server knows we've viewed the conversation even if messages
        // were already marked as read locally
        if hasUnreadFromOther {
            Task {
                do {
                    FileLogger.shared.log("üì§ Notifying server about read status for user \(userId)", category: "MessagingService")
                    try await APIService.shared.markMessagesAsRead(userId: userId)
                    let successLog = "‚úÖ Server notified of read status for user \(userId)"
                    FileLogger.shared.log(successLog, category: "MessagingService")
                    print("‚úÖ MessagingService: \(successLog)")
                } catch {
                    let errorLog = "‚ö†Ô∏è Failed to notify server of read status - \(error)"
                    FileLogger.shared.log(errorLog, category: "MessagingService")
                    print("‚ö†Ô∏è MessagingService: \(errorLog)")
                }
            }
        }
    }

    func getMessages(for userId: Int) -> [Message] {
        return conversations[userId] ?? []
    }

    private func updateUnreadCounts() {
        for (userId, messages) in conversations {
            let unreadCount = messages.filter { !$0.isRead && !$0.isSentByCurrentUser }.count
            unreadCounts[userId] = unreadCount
        }

        // „Ç¢„Éó„É™„Éê„ÉÉ„Ç∏„ÇíÊõ¥Êñ∞
        updateAppBadge()
    }

    private func updateAppBadge() {
        // ÂÖ®„Å¶„ÅÆÊú™Ë™≠Êï∞„ÇíÂêàË®à
        let totalUnreadCount = unreadCounts.values.reduce(0, +)

        // „É°„Ç§„É≥„Çπ„É¨„ÉÉ„Éâ„Åß„Éê„ÉÉ„Ç∏„ÇíÊõ¥Êñ∞
        DispatchQueue.main.async {
            if #available(iOS 16.0, *) {
                UNUserNotificationCenter.current().setBadgeCount(totalUnreadCount) { error in
                    if let error = error {
                        print("‚ùå MessagingService: Failed to update badge - \(error)")
                    } else {
                        print("‚úÖ MessagingService: Updated badge count to \(totalUnreadCount)")
                    }
                }
            } else {
                // iOS 15„ÅÆÂ†¥Âêà„ÅØUIApplication„ÅßË®≠ÂÆö
                UIApplication.shared.applicationIconBadgeNumber = totalUnreadCount
                print("‚úÖ MessagingService: Updated badge count to \(totalUnreadCount) (iOS 15)")
            }
        }
    }

    /// „Éê„ÉÉ„Ç∏„Çí„ÇØ„É™„Ç¢Ôºà„É≠„Ç∞„Ç¢„Ç¶„ÉàÊôÇ„Å™„Å©„Å´‰ΩøÁî®Ôºâ
    func clearAppBadge() {
        DispatchQueue.main.async {
            if #available(iOS 16.0, *) {
                UNUserNotificationCenter.current().setBadgeCount(0) { error in
                    if let error = error {
                        print("‚ùå MessagingService: Failed to clear badge - \(error)")
                    } else {
                        print("‚úÖ MessagingService: Cleared badge")
                    }
                }
            } else {
                // iOS 15„ÅÆÂ†¥Âêà„ÅØUIApplication„ÅßË®≠ÂÆö
                UIApplication.shared.applicationIconBadgeNumber = 0
                print("‚úÖ MessagingService: Cleared badge (iOS 15)")
            }
        }
    }

    func clearMessages(with userId: Int) async {
        // Delete from server first
        do {
            try await APIService.shared.deleteMessages(userId: userId)
            print("‚úÖ MessagingService: Deleted messages from server for user \(userId)")
        } catch {
            print("‚ö†Ô∏è MessagingService: Failed to delete from server - \(error)")
        }

        await MainActor.run {
            conversations.removeValue(forKey: userId)
            unreadCounts.removeValue(forKey: userId)
        }

        // Delete from local storage
        guard let currentUserId = AuthService.shared.currentUser?.id else { return }
        var allMessages = LocalStorageManager.shared.loadMessages()
        allMessages.removeAll { message in
            (message.senderId == userId && message.receiverId == currentUserId) ||
            (message.senderId == currentUserId && message.receiverId == userId)
        }
        LocalStorageManager.shared.saveMessages(allMessages)

        print("‚úÖ MessagingService: Cleared messages with user \(userId)")
    }

    func deleteConversation(with userId: Int) {
        conversations.removeValue(forKey: userId)
        unreadCounts.removeValue(forKey: userId)

        // Delete from local storage
        guard let currentUserId = AuthService.shared.currentUser?.id else { return }
        var allMessages = LocalStorageManager.shared.loadMessages()
        allMessages.removeAll { message in
            (message.senderId == userId && message.receiverId == currentUserId) ||
            (message.senderId == currentUserId && message.receiverId == userId)
        }
        LocalStorageManager.shared.saveMessages(allMessages)

        print("‚úÖ MessagingService: Deleted conversation with \(userId)")
    }

    // MARK: - Polling

    func startPolling(for contactId: Int) {
        stopPolling()
        activeConversationUserId = contactId

        // ÂàùÂõû„ÅÆÂèñÂæó
        Task {
            await fetchMessages(for: contactId)
        }

        // 2Áßí„Åî„Å®„Å´Êñ∞ÁùÄ„É°„ÉÉ„Çª„Éº„Ç∏„Çí„ÉÅ„Çß„ÉÉ„ÇØ
        messageTimer = Timer.scheduledTimer(withTimeInterval: 2.0, repeats: true) { [weak self] _ in
            Task {
                await self?.fetchMessages(for: contactId)
            }
        }
        print("‚úÖ MessagingService: Started polling every 2 seconds for user \(contactId)")
    }

    func stopPolling() {
        messageTimer?.invalidate()
        messageTimer = nil
        activeConversationUserId = nil
        print("‚úÖ MessagingService: Stopped polling")
    }

    func refreshMessages(for userId: Int) async {
        await fetchMessages(for: userId)
    }
}

// MARK: - Notification Names

extension Notification.Name {
    static let newMessageReceived = Notification.Name("newMessageReceived")
}
